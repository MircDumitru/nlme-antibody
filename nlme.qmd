# NLME model - no covariates

::: content-hidden
$$
{{< include _macros.tex >}}
{{< include _packages.tex >}}
$$
:::

```{r}
#| echo: false

source("_settings.R")
```

## Introduction

### Prerequisites

```{r}
#| warning: false
#| message: false

library(tidyverse)  # tidyverse 
library(nlme)       # non-linear mixed effect models
library(saemix)     # nlme package for saemix objects
```


## NLME with no covariates

```{r}
#| code-fold: true
#| message: false
#| warning: false

tb <- read_csv("data/data_ebola_ab.csv")

tb <- tb |>
  # clean the names
  janitor::clean_names() |>
  # transform chr into factors
  mutate(across(where(is.character), fct))

tb_clean <- tb |>
  filter(age >= 0)

tb_clean <- tb_clean |>
  mutate(age_updated = age + time / 365) |>
  relocate(age_updated, .after = age)

tb_after_7 <- tb_clean |>
  filter(time != 0)
```



Will be done via stochastic approximation expectation maximization (SAEM) using the `saemix` package.

First thing: account for the specificity of `saemix` which expects the `id` column in the data frame to be of numerical type. The next chunk is re-transforming the `id` column in the tibble into a numerical variable and parse the numerical value (i.e. removes "ID" from "IDi")

```{r}
#| code-fold: true
#| warning: false

tb_after_7 <- tb_after_7 |>
  mutate(
    id = parse_number(as.character(id))
    )
tb_after_7
```


The next chunk is defining the data as a `saemix` object, via `saemixData`. 

```{r}
#| code-fold: true

saemix_data_nlme <- saemixData(
  name.data = tb_after_7,
  name.group = "id",
  name.predictors = "time",
  name.response = "abelisa",
  units = list(x = "Days", y = "EU/ml")
)
```


```{r}
saemix_data_nlme
```

The next chunk implements the function from @eq-f-approx:

```{r}
#| code-fold: true

function_approx <- function(psi, id, xidep){
  time <- xidep[, 1]
  y_min <- psi[id, 1]
  y_max <- psi[id, 2]
  rate <- psi[id, 3]
  fpred <- y_min + (y_max - y_min) * exp(-rate * time)
  return(fpred)
}
#function_approx
```

The next chunk is defining the nlme model as a `saemix` object, via `saemixModel` function. The model is given by @eq-f-approx, the initial values for $\phi_1$ and $\phi_2$ are set via the range computed over the complete data and the rate $r$ is set at $0.05$. The model considers random effects on all three parameters & constant variance, `error.model = "constant"`. 

```{r}
#| code-fold: true

saemix_model_nlme <- saemixModel(
  model = function_approx,
  description = "Approx function", 
  psi0 = matrix(
    c(1.6, 4.9, 0.05),
    ncol = 3, 
    byrow = TRUE, 
    dimnames = list(NULL, c("y_min", "y_max", "rate"))),
  transform.par = c(0, 0, 1),   # log-transform rate only
  covariance.model = diag(1, 3),  # random effects on all
  error.model = "constant"
  )
# saemix_model_nlme
```

```{r}
saemix_model_nlme
```

The next chunk is defining the nlme model's parameters as a (regular R) list:

```{r}
#| code-fold: true

saemix_options_nlme <- list(
  seed = 42,
  save = FALSE, 
  save.graph = FALSE,
  displayProgress = FALSE,
  print = FALSE
  )
#saemix_options_nlme
```

The next chunk is fitting the nlme model, a `saemix` object, created via `saemix` function.

```{r}
#| code-fold: true

saemix_fit_nlme <- saemix(
  saemix_model_nlme,
  saemix_data_nlme,
  saemix_options_nlme
  )
# saemix_fit_nlme
```

The results are

```{r}
saemix_fit_nlme@results
```

```{r}
saemix_fit_nlme@results@fixed.effects
```

The following chunk plots the comparison between the observed and the (individual and population) prediction for subject 1:

```{r}
#| code-fold: true

fit_with_preds <- saemix.predict(saemix_fit_nlme)
tb_data <- fit_with_preds@data@data
tb_predictions <- fit_with_preds@results@predictions

tb_complete <- cbind(tb_data, tb_predictions)

ggplot(subset(tb_complete, id == 1), aes(x = time)) +
  geom_point(aes(y = abelisa, color = "Observed"), size = 2) +
  geom_line(aes(y = ipred, color = "Individual prediction"), linewidth = 1.5) +
  geom_line(aes(y = ypred, color = "Population prediction"), linewidth = 1.5, linetype = "dashed") +
  scale_color_manual(
    name = NULL,
    values = c(
      "Observed" = "tomato",
      "Individual prediction" = "darkseagreen",
      "Population prediction" = "violet"
    )
  ) +
  labs(
    title = str_c("Subject", 1, ": Obseved vs. Prediction", sep = " "),
    x = "Time",
    y = "Antibody levels (EU/ml)"
  ) +
  theme_bw() +
  theme(
    legend.direction = "horizontal",
    legend.position = "bottom",
  )
```

The following chunk plots the comparison between the observed and the (individual and population) prediction for the subjects in the data set. 

```{r}
#| code-fold: true
#| warning: false
#| fig-width: 12
#| fig-height: 10

ggplot(tb_complete, aes(x = time)) +
  geom_point(aes(y = abelisa), color = "tomato", size = 2) +
  geom_line(aes(y = ipred), color = "darkseagreen", linewidth = 1.5) +
  geom_line(aes(y = ypred), color = "violet", linewidth = 1.5, linetype = "dashed") +
  labs(
    title = NULL,
    x = NULL,
    y = NULL
  ) +
  facet_wrap(~ id) +
  theme_bw()
```


```{r}
#| code-fold: true
#| label: fig-fixed-effects-iterations
#| fig-cap: "Fixed effects during iterations"
#| fig-subcap: 
#|   - "y_min"
#|   - "y_max"
#|   - "rate"
#| fig-width: 3
#| layout-ncol: 3

psi <- psi(saemix_fit_nlme) |>
  as_tibble() |>
  rowid_to_column("iteration")

psi |>
  ggplot(aes(x = iteration, y = y_min)) +
  geom_line(color = "tomato") +
  labs(
    x = "Iteration",
    y = "y_min"    
  ) +
  theme_bw()

psi |>
  ggplot(aes(x = iteration, y = y_max)) +
  geom_line(color = "tomato") +
  labs(
    x = "Iteration",
    y = "y_max"    
  ) +
  theme_bw()

psi |>
  ggplot(aes(x = iteration, y = rate)) +
  geom_line(color = "tomato") +
  labs(
    x = "Iteration",
    y = "rate"    
  ) +
  theme_bw()
```

